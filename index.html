<!-- File: index.html -->
<!--
Vitals Tracker — Function-First Shell
Copyright (c) 2026 Wendell K. Jiles. All rights reserved.
App Version: v2.020
Base: v2.019
Date: 2026-01-17

Change Log (v2.020)
1) Hypertension systolic bands increased to ~75% opacity for clearer visual correlation.
2) Chart right padding reduced (tighter plot) while preserving non-clipping behavior.
3) X-axis labels never overlap: labels are selectively dropped (tick marks still drawn) to maintain readability.
4) No other behavior changes intended.

File Structure / Reference Points
- Panels: #panelHome, #panelLog, #panelCharts
- Chart: #canvasWrap (gesture surface), #chartCanvas (canvas)
- Log: #logList (UL), #logMoreLink (paging link)
Dependencies expected:
- ./js/storage.js
- ./js/gestures.js
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b1324" />
  <title>Vitals Tracker</title>

  <style>
    :root{
      --bg0:#08101f;
      --bg1:#0b1324;
      --panel:#0c1528cc;
      --stroke:rgba(235,245,255,.16);
      --stroke2:rgba(235,245,255,.22);
      --strokeBold:rgba(180,210,255,.42);
      --text:rgba(235,245,255,.88);
      --muted:rgba(235,245,255,.58);
      --muted2:rgba(235,245,255,.42);
      --accent:#2b4e7a;
      --shadow:0 18px 42px rgba(0,0,0,.45);
      --r:22px;
      --r2:26px;
      --pad:16px;
      --gap:12px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(70,140,255,.20), transparent 60%),
        radial-gradient(900px 600px at 90% 10%, rgba(80,160,255,.12), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow:hidden;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding:14px 12px calc(14px + env(safe-area-inset-bottom));
      gap:12px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      border:1px solid var(--stroke2);
      border-radius:999px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
    }
    .title{font-weight:800; letter-spacing:.2px; font-size:22px;}
    .boot{font-size:13px; color:var(--muted); letter-spacing:.25px; white-space:nowrap;}

    .shell{
      flex:1;
      min-height:0;
      border:2px solid rgba(60,120,210,.55);
      border-radius: var(--r2);
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .panels{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow:hidden;
    }
    .panel{
      height:100%;
      display:none;
      flex-direction:column;
      gap:12px;
      overflow:hidden;
    }
    .panel.active{display:flex}

    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid var(--stroke2);
      border-radius:999px;
      padding:12px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .panelHeader .name{
      font-size:18px;
      font-weight:800;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:56%;
    }

    .nav{display:flex; gap:8px;}
    .btn{
      border:1px solid var(--stroke2);
      color:var(--text);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border-radius:999px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:active{transform: translateY(1px)}
    .btn.secondary{
      color:var(--muted);
      border-color:var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      font-weight:700;
    }
    .btn.primary{
      border-color: rgba(120,180,255,.45);
      background: linear-gradient(180deg, rgba(80,150,255,.34), rgba(80,150,255,.14));
    }
    .btn[disabled]{opacity:.55; cursor:not-allowed}

    .card{
      border:1px solid var(--stroke2);
      border-radius: var(--r);
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      overflow:auto;
      min-height:0;
    }
    .muted{color:var(--muted)}
    .small{font-size:13px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

    .kv{
      display:grid;
      grid-template-columns: 110px 1fr;
      gap:8px 12px;
      margin-top:10px;
      font-size:15px;
    }
    .kv .k{color:var(--muted)}
    .kv .v{color:var(--text); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .list{
      margin:0;
      padding:0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:10px 12px;
      background: rgba(0,0,0,.18);
    }
    .rowTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-weight:800;
    }
    .rowSub{margin-top:6px; color:var(--muted); font-size:13px; line-height:1.25}
    .pill{
      padding:4px 10px;
      border-radius:999px;
      border:1px solid var(--stroke2);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }

    .canvasWrap{
      border:1px solid var(--stroke2);
      border-radius: var(--r);
      padding:6px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
      touch-action:none;
    }
    canvas{
      display:block;
      width:100%;
      height:280px;
    }

    .hint{margin-top:10px; color:var(--muted); line-height:1.35;}

    .pull{
      height:0px;
      overflow:hidden;
      transition:height .18s ease;
      color:var(--muted);
      font-weight:800;
      letter-spacing:.2px;
      text-align:center;
    }

    .linkish{
      margin-top:12px;
      display:inline-block;
      color:rgba(170,210,255,.92);
      font-weight:900;
      letter-spacing:.15px;
      text-decoration:none;
      border:1px solid rgba(170,210,255,.30);
      background: rgba(60,120,210,.12);
      padding:10px 12px;
      border-radius:999px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .linkish:active{transform:translateY(1px)}

    /* Chart label: hard single line, centered */
    #chartsTopNote{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      text-align:center;
      display:block;
      padding:0 10px;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="title">Vitals Tracker</div>
      <div class="boot" id="bootText">BOOT OK v2.020</div>
    </div>

    <div class="shell">
      <div class="panels" id="panelsRoot">

        <!-- HOME PANEL -->
        <section class="panel active" id="panelHome" aria-label="Home">
          <div class="panelHeader">
            <div class="name">Home</div>
            <div class="nav">
              <button class="btn secondary" id="btnHome">Home</button>
              <button class="btn secondary" id="btnLog">Log</button>
              <button class="btn secondary" id="btnCharts">Charts</button>
              <button class="btn primary" id="btnInstall" disabled>Install</button>
            </div>
          </div>

          <div class="pull" id="pullIndicator">Release to refresh</div>

          <div class="card" id="homeCard">
            <div class="muted">Function-first shell. Data detection is read-only.</div>
            <div class="hint small">
              Pull down on Home to refresh (release).
              <div id="bridgeStatus" class="small" style="margin-top:10px;"></div>
            </div>

            <div class="card" style="margin-top:12px;" id="detectedCard">
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div style="font-weight:900; font-size:20px;">Data Detected (Read-Only)</div>
                <span class="pill" id="detectedPill">—</span>
              </div>
              <div class="kv" aria-label="Data summary">
                <div class="k">Source</div><div class="v" id="sumSource">Not loaded</div>
                <div class="k">Entries</div><div class="v" id="sumEntries">—</div>
                <div class="k">Newest</div><div class="v mono" id="sumNewest">—</div>
              </div>
            </div>
          </div>
        </section>

        <!-- LOG PANEL -->
        <section class="panel" id="panelLog" aria-label="Log">
          <div class="panelHeader">
            <div class="name">Log (read-only)</div>
            <div class="nav">
              <button class="btn secondary" id="btnBackFromLog">Home</button>
              <button class="btn secondary" id="btnChartsFromLog">Charts</button>
            </div>
          </div>

          <div class="card" id="logCard">
            <div class="muted" id="logTopNote">Loading…</div>
            <ul class="list" id="logList" style="margin-top:12px;"></ul>
            <a href="#" class="linkish" id="logMoreLink" style="display:none;">Load next 25</a>
          </div>
        </section>

        <!-- CHARTS PANEL -->
        <section class="panel" id="panelCharts" aria-label="Charts">
          <div class="panelHeader">
            <div class="name">Charts (Read-Only)</div>
            <div class="nav">
              <button class="btn secondary" id="btnBackFromCharts">Home</button>
              <button class="btn secondary" id="btnLogFromCharts">Log</button>
            </div>
          </div>

          <div class="card" id="chartsCard" style="padding:12px;">
            <div class="muted" id="chartsTopNote">Loading…</div>
            <div class="canvasWrap" id="canvasWrap" style="margin-top:10px;">
              <canvas id="chartCanvas"></canvas>
            </div>
          </div>
        </section>

      </div>
    </div>
  </div>

  <script src="./js/storage.js?v=2.020"></script>
  <script src="./js/gestures.js?v=2.020"></script>

  <script>
    (function(){
      const APP_VERSION = "v2.020";
      const TZ = "America/Chicago";
      const MS_HOUR = 3600000;
      const MS_DAY  = 86400000;

      const panelHome = document.getElementById("panelHome");
      const panelLog = document.getElementById("panelLog");
      const panelCharts = document.getElementById("panelCharts");

      function showPanel(which){
        panelHome.classList.remove("active");
        panelLog.classList.remove("active");
        panelCharts.classList.remove("active");
        if(which === "home") panelHome.classList.add("active");
        if(which === "log") panelLog.classList.add("active");
        if(which === "charts") panelCharts.classList.add("active");
        if(which === "charts"){
          setupCanvas();
          renderCharts();
        }
      }

      const btnHome = document.getElementById("btnHome");
      const btnLog = document.getElementById("btnLog");
      const btnCharts = document.getElementById("btnCharts");
      const btnInstall = document.getElementById("btnInstall");

      document.getElementById("btnBackFromLog").onclick = () => showPanel("home");
      document.getElementById("btnChartsFromLog").onclick = () => showPanel("charts");
      document.getElementById("btnBackFromCharts").onclick = () => showPanel("home");
      document.getElementById("btnLogFromCharts").onclick = () => showPanel("log");

      btnHome.onclick = () => showPanel("home");
      btnLog.onclick = () => showPanel("log");
      btnCharts.onclick = () => showPanel("charts");

      const pullIndicator = document.getElementById("pullIndicator");
      let pullStartY = null;
      let pullArmed = false;

      panelHome.addEventListener("touchstart", (e) => {
        const homeCard = document.getElementById("homeCard");
        if(homeCard.scrollTop !== 0) return;
        pullStartY = e.touches[0].clientY;
        pullArmed = false;
      }, {passive:true});

      panelHome.addEventListener("touchmove", (e) => {
        if(pullStartY == null) return;
        const dy = e.touches[0].clientY - pullStartY;
        if(dy > 0){
          const h = Math.min(48, Math.floor(dy/2));
          pullIndicator.style.height = h + "px";
          pullArmed = (h >= 36);
        }
      }, {passive:true});

      panelHome.addEventListener("touchend", () => {
        if(pullStartY == null) return;
        const armed = pullArmed;
        pullStartY = null;
        pullArmed = false;
        pullIndicator.style.height = "0px";
        if(armed) location.reload();
      });

      let deferredPrompt = null;
      window.addEventListener("beforeinstallprompt", (e) => {
        e.preventDefault();
        deferredPrompt = e;
        btnInstall.disabled = false;
      });

      btnInstall.addEventListener("click", async () => {
        try{
          if(!deferredPrompt) return;
          deferredPrompt.prompt();
          await deferredPrompt.userChoice;
        } finally {
          deferredPrompt = null;
          btnInstall.disabled = true;
        }
      });

      if("serviceWorker" in navigator){
        navigator.serviceWorker.register("./sw.js?v=2.020").catch(()=>{});
      }

      const bridgeStatus = document.getElementById("bridgeStatus");
      const sumSource = document.getElementById("sumSource");
      const sumEntries = document.getElementById("sumEntries");
      const sumNewest = document.getElementById("sumNewest");
      const detectedPill = document.getElementById("detectedPill");

      const logTopNote = document.getElementById("logTopNote");
      const logList = document.getElementById("logList");
      const logMoreLink = document.getElementById("logMoreLink");

      const chartsTopNote = document.getElementById("chartsTopNote");
      const canvasWrap = document.getElementById("canvasWrap");
      const chartCanvas = document.getElementById("chartCanvas");

      let ctx = null;

      function setupCanvas(){
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const rect = chartCanvas.getBoundingClientRect();
        const cssW = Math.max(280, Math.floor(rect.width));
        const cssH = Math.max(220, Math.floor(rect.height));
        chartCanvas.width  = Math.floor(cssW * dpr);
        chartCanvas.height = Math.floor(cssH * dpr);
        ctx = chartCanvas.getContext("2d", { alpha:true, desynchronized:true });
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.imageSmoothingEnabled = false;
      }

      const fmtYMDParts = new Intl.DateTimeFormat("en-US", {
        timeZone: TZ,
        year:"numeric", month:"2-digit", day:"2-digit"
      });

      const fmtTimeCT = new Intl.DateTimeFormat("en-US", {
        timeZone: TZ,
        hour:"numeric", minute:"2-digit", hour12:true
      });

      function fmtCTDateOnly(ms){
        try{
          if(!Number.isFinite(ms)) return "—";
          const parts = fmtYMDParts.formatToParts(new Date(ms));
          const map = {};
          for(const p of parts) map[p.type]=p.value;
          return `${map.year}-${map.month}-${map.day}`;
        }catch(_){
          return "—";
        }
      }

      function fmtCTDateTime(ms){
        if(!Number.isFinite(ms) || ms<=0) return "—";
        return `${fmtCTDateOnly(ms)} ${fmtTimeCT.format(new Date(ms))}`;
      }

      function ctParts(ms){
        const parts = fmtYMDParts.formatToParts(new Date(ms));
        const get = (t)=> parts.find(p=>p.type===t)?.value || "";
        return { y:+get("year"), m:+get("month"), d:+get("day") };
      }
      function ctDayKey(ms){
        const p = ctParts(ms);
        return `${p.y}-${String(p.m).padStart(2,"0")}-${String(p.d).padStart(2,"0")}`;
      }

      function safeNum(x){
        const n = Number(x);
        return Number.isFinite(n) ? n : null;
      }

      function extractTs(r){
        return r.ts || r.time || r.timestamp || r.date || r.createdAt || r.created_at || r.iso || null;
      }

      function extractBP(r){
        const sys = safeNum(r.sys ?? r.systolic ?? (r.bp && (r.bp.sys ?? r.bp.systolic)));
        const dia = safeNum(r.dia ?? r.diastolic ?? (r.bp && (r.bp.dia ?? r.bp.diastolic)));
        return { sys, dia };
      }

      function extractHR(r){
        return safeNum(r.hr ?? r.heartRate ?? r.pulse ?? (r.vitals && (r.vitals.hr ?? r.vitals.pulse)));
      }

      function extractNotes(r){
        return (r.notes ?? r.note ?? r.symptomsNote ?? r.text ?? "").toString();
      }

      let records = [];
      let summary = { source:"Not loaded", entries:0, newest:null };

      function renderSummary(){
        sumSource.textContent = summary.source || "—";
        sumEntries.textContent = String(summary.entries ?? "—");
        sumNewest.textContent = summary.newest ? fmtCTDateOnly(new Date(summary.newest).getTime()) : "—";
        detectedPill.textContent = summary.entries ? (summary.entries + " entries") : "—";
      }

      let logOffset = 0;

      function sortedNewest(){
        return [...records].sort((a,b)=>{
          const ta = new Date(extractTs(a) || 0).getTime();
          const tb = new Date(extractTs(b) || 0).getTime();
          return tb - ta;
        });
      }

      function renderLog(reset){
        if(reset){ logOffset = 0; }
        logList.innerHTML = "";
        logMoreLink.style.display = "none";

        if(!records.length){
          logTopNote.textContent = "No records detected (read-only).";
          return;
        }

        const all = sortedNewest();
        const slice = all.slice(logOffset, logOffset + 25);

        logTopNote.textContent = `Showing ${Math.min(logOffset+slice.length, all.length)} of ${all.length} records (read-only).`;

        for(let i=0;i<slice.length;i++){
          const r = slice[i];
          const tsRaw = extractTs(r);
          const tms = new Date(tsRaw || 0).getTime();
          const {sys,dia} = extractBP(r);
          const hr = extractHR(r);
          const notes = extractNotes(r);

          const topLeft = (sys!=null && dia!=null) ? `${sys}/${dia}` : (sys!=null || dia!=null ? `${sys ?? "—"}/${dia ?? "—"}` : "—");
          const topRight = (hr!=null) ? `HR ${hr}` : "—";
          const when = (Number.isFinite(tms) && tms>0) ? fmtCTDateTime(tms) : "—";

          const li = document.createElement("li");
          li.className = "row";
          li.dataset.index = String(logOffset + i);

          const t = document.createElement("div");
          t.className = "rowTop";
          t.innerHTML = `<div>${topLeft}</div><div class="pill">${topRight}</div>`;

          const s = document.createElement("div");
          s.className = "rowSub";
          const noteTrim = notes && notes.trim() ? ` • ${notes.trim().slice(0,140)}` : "";
          s.textContent = `${when}${noteTrim}`;

          li.appendChild(t);
          li.appendChild(s);
          logList.appendChild(li);
        }

        if(logOffset + 25 < all.length){
          logMoreLink.style.display = "inline-block";
        }
      }

      logMoreLink.addEventListener("click", (e)=>{
        e.preventDefault();
        const all = sortedNewest();
        logOffset = Math.min(all.length, logOffset + 25);
        renderLog(false);

        const firstNew = logList.querySelector(`li.row[data-index="${logOffset}"]`);
        if(firstNew){
          firstNew.scrollIntoView({ block:"start", behavior:"instant" });
          firstNew.tabIndex = -1;
          try{ firstNew.focus({ preventScroll:true }); }catch(_){}
        }else{
          logList.scrollIntoView({ block:"start", behavior:"instant" });
        }
      });

      const view = {
        windowDays: 7,
        minDays: 1,
        maxDays: 14,
        centerMs: null,
        tMinData: null,
        tMaxData: null
      };

      function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

      let Y_MIN = 40;
      let Y_MAX = 200;

      function computeGlobalYMaxFromDB(){
        let maxSys = null;
        for(const r of records){
          const bp = extractBP(r);
          if(bp.sys != null){
            maxSys = (maxSys == null) ? bp.sys : Math.max(maxSys, bp.sys);
          }
        }
        if(maxSys == null) return 200;

        const pad = 6;
        const raw = maxSys + pad;
        const nice = Math.ceil(raw / 10) * 10;
        return Math.max(120, nice);
      }

      function rebuildBands(){
        // More opaque (~75%) systolic bands
        return [
          { name:"HTN2",      y0:140, y1:Y_MAX, fill:"rgba(255, 70, 70, .75)" },
          { name:"HTN1",      y0:130, y1:140,  fill:"rgba(255, 210, 80, .75)" },
          { name:"Optimal",   y0: 90, y1:130,  fill:"rgba(80, 160, 255, .75)" },
          { name:"Hypotens.", y0: Y_MIN, y1: 90, fill:"rgba(170, 120, 255, .75)" }
        ];
      }
      let SYS_BANDS = rebuildBands();

      function computeDataTimeBounds(){
        let tMin = Infinity, tMax = -Infinity;
        for(const r of records){
          const t = new Date(extractTs(r) || 0).getTime();
          if(Number.isFinite(t) && t>0){
            tMin = Math.min(tMin, t);
            tMax = Math.max(tMax, t);
          }
        }
        if(!Number.isFinite(tMin) || !Number.isFinite(tMax) || tMin===Infinity || tMax===-Infinity){
          return { tMin:null, tMax:null };
        }
        return { tMin, tMax };
      }

      function ensureViewCenter(){
        if(view.centerMs != null) return;
        const { tMin, tMax } = computeDataTimeBounds();
        view.tMinData = tMin;
        view.tMaxData = tMax;
        if(tMin != null && tMax != null){
          const wMs = view.windowDays * MS_DAY;
          view.centerMs = clamp(tMax - (wMs*0.35), tMin + wMs*0.5, tMax - wMs*0.5);
        }
      }

      function getVisibleRange(){
        ensureViewCenter();
        if(view.centerMs == null || view.tMinData == null || view.tMaxData == null){
          return { t0:0, t1:0, ok:false };
        }
        const wMs = view.windowDays * MS_DAY;
        let t0 = view.centerMs - wMs/2;
        let t1 = view.centerMs + wMs/2;

        if(t0 < view.tMinData){
          const shift = view.tMinData - t0;
          t0 += shift; t1 += shift;
        }
        if(t1 > view.tMaxData){
          const shift = t1 - view.tMaxData;
          t0 -= shift; t1 -= shift;
        }

        t0 = Math.max(view.tMinData, t0);
        t1 = Math.min(view.tMaxData, t1);
        return { t0, t1, ok:true };
      }

      function clearCanvas(){
        if(!ctx) return;
        const rect = chartCanvas.getBoundingClientRect();
        ctx.clearRect(0,0,rect.width, rect.height);
      }

      function drawPlotFrame(){
        const rect = chartCanvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;

        // Less right padding per v2.020 request (tighter plot)
        const padL = 30, padR = 12, padT = 10, padB = 42;
        const x0 = padL, y0 = padT, pw = w - padL - padR, ph = h - padT - padB;

        ctx.strokeStyle = "rgba(235,245,255,.14)";
        ctx.lineWidth = 1;
        ctx.strokeRect(x0, y0, pw, ph);

        return { padL, padR, padT, padB, x0, y0, pw, ph, w, h };
      }

      function yToPx(y, frame){
        const { y0, ph } = frame;
        const t = (y - Y_MIN) / Math.max(1, (Y_MAX - Y_MIN));
        return y0 + (1 - t) * ph;
      }

      function computeDayBoundaries(t0, t1){
        const bounds = [];
        if(!Number.isFinite(t0) || !Number.isFinite(t1) || t1<=t0) return bounds;

        let t = Math.floor(t0 / MS_HOUR) * MS_HOUR;
        let prevKey = ctDayKey(t);

        while(t < t1 + MS_HOUR){
          const tNext = t + MS_HOUR;
          const nextKey = ctDayKey(tNext);
          if(nextKey !== prevKey){
            let lo = t, hi = tNext;
            for(let i=0;i<12;i++){
              const mid = Math.floor((lo+hi)/2);
              if(ctDayKey(mid) === prevKey) lo = mid; else hi = mid;
            }
            const boundary = hi;
            if(boundary >= t0 && boundary <= t1) bounds.push(boundary);
            prevKey = nextKey;
          }
          t = tNext;
        }
        return bounds.sort((a,b)=>a-b);
      }

      function drawAlternatingDays(frame, t0, t1){
        const { x0, y0, pw, ph } = frame;
        const bounds = computeDayBoundaries(t0, t1);
        const cuts = [t0, ...bounds, t1].filter((v,i,a)=> i===0 || v>a[i-1]);

        const p = ctParts(t0);
        let parity = (p.d % 2);

        for(let i=0;i<cuts.length-1;i++){
          const a = cuts[i], b = cuts[i+1];
          const xa = x0 + ((a - t0)/(t1 - t0)) * pw;
          const xb = x0 + ((b - t0)/(t1 - t0)) * pw;

          const isAlt = ((parity + i) % 2) === 0;
          ctx.fillStyle = isAlt ? "rgba(40,90,170,.12)" : "rgba(0,0,0,.12)";
          ctx.fillRect(xa, y0, Math.max(0, xb-xa), ph);
        }
      }

      function drawSystolicBands(frame){
        const { x0, pw } = frame;
        for(const b of SYS_BANDS){
          const yTop = yToPx(b.y1, frame);
          const yBot = yToPx(b.y0, frame);
          const h = Math.max(0, yBot - yTop);
          ctx.fillStyle = b.fill;
          ctx.fillRect(x0, yTop, pw, h);
        }
      }

      function buildNiceYTicks(){
        const span = Math.max(1, Y_MAX - Y_MIN);
        let step = 20;
        if(span <= 90) step = 10;
        else if(span <= 160) step = 20;
        else step = 20;

        const start = Math.floor(Y_MIN / step) * step;
        const ticks = [];
        for(let v=start; v<=Y_MAX; v+=step){
          if(v >= Y_MIN) ticks.push(v);
        }
        if(ticks[ticks.length-1] !== Y_MAX) ticks.push(Y_MAX);
        return ticks;
      }

      function drawYGridAndLabels(frame){
        const { x0, pw } = frame;
        const ticks = buildNiceYTicks();

        ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillStyle = "rgba(235,245,255,.58)";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        for(const val of ticks){
          const y = yToPx(val, frame);
          ctx.strokeStyle = "rgba(235,245,255,.10)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x0+pw, y);
          ctx.stroke();
          ctx.fillText(String(val), 4, y);
        }
      }

      function hour12Num(ms){
        try{
          const parts = new Intl.DateTimeFormat("en-US", {
            timeZone: TZ, hour:"numeric", hour12:true
          }).formatToParts(new Date(ms));
          return (parts.find(p=>p.type==="hour")?.value || "");
        }catch(_){
          return "";
        }
      }

      function chooseXTicks(t0, t1){
        const spanDays = (t1 - t0) / MS_DAY;
        const out = [];

        if(spanDays <= 2.0){
          const step = 4 * MS_HOUR;
          let t = Math.ceil(t0/step)*step;
          while(t <= t1){
            out.push({ t, labelTop: hour12Num(t), labelBot: "" });
            t += step;
          }
          return { ticks: out, hourMode: true };
        }

        const fmtDay = new Intl.DateTimeFormat("en-US", { timeZone: TZ, weekday:"short" });
        const fmtMD  = new Intl.DateTimeFormat("en-US", { timeZone: TZ, month:"2-digit", day:"2-digit" });

        const bounds = computeDayBoundaries(t0, t1);
        const cuts = [t0, ...bounds].filter(v=>v>=t0 && v<=t1);

        for(const t of cuts){
          out.push({ t, labelTop: fmtDay.format(new Date(t)), labelBot: fmtMD.format(new Date(t)) });
        }
        return { ticks: out, hourMode: false };
      }

      // X-axis labels never overlap: drop selectively while keeping tick marks
      function drawXLabels(frame, t0, t1){
        const { x0, y0, pw, ph } = frame;
        const { ticks, hourMode } = chooseXTicks(t0, t1);

        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillStyle = "rgba(235,245,255,.58)";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";

        let lastRight = -Infinity;
        const minGap = 6;

        for(const tick of ticks){
          const x = x0 + ((tick.t - t0) / (t1 - t0)) * pw;

          // Tick mark always drawn
          ctx.strokeStyle = "rgba(235,245,255,.10)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y0 + ph);
          ctx.lineTo(x, y0 + ph + 5);
          ctx.stroke();

          const top = (tick.labelTop || "").trim();
          const bot = (!hourMode && tick.labelBot) ? (tick.labelBot || "").trim() : "";

          const wTop = top ? ctx.measureText(top).width : 0;
          const wBot = bot ? ctx.measureText(bot).width : 0;
          const w = Math.max(wTop, wBot);

          const left = x - w/2;
          const right = x + w/2;

          if(left <= lastRight + minGap){
            continue;
          }

          if(top) ctx.fillText(top, x, y0 + ph + 8);
          if(bot) ctx.fillText(bot, x, y0 + ph + 22);

          lastRight = right;
        }
      }

      function buildSeriesVisible(t0, t1){
        const sys = [];
        const dia = [];
        const hr  = [];

        for(const r of records){
          const t = new Date(extractTs(r) || 0).getTime();
          if(!Number.isFinite(t) || t<=0) continue;
          if(t < t0 || t > t1) continue;

          const bp = extractBP(r);
          const h = extractHR(r);

          if(bp.sys != null) sys.push({t, y: bp.sys});
          if(bp.dia != null) dia.push({t, y: bp.dia});
          if(h != null)      hr.push({t, y: h});
        }

        sys.sort((a,b)=>a.t-b.t);
        dia.sort((a,b)=>a.t-b.t);
        hr.sort((a,b)=>a.t-b.t);

        return { sys, dia, hr };
      }

      function plotLine(points, frame, t0, t1, stroke, alpha){
        if(points.length < 2) return;
        const { x0, pw } = frame;

        ctx.save();
        ctx.strokeStyle = stroke;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = 1.35;
        ctx.lineJoin = "miter";
        ctx.lineCap = "butt";

        ctx.beginPath();
        for(let i=0;i<points.length;i++){
          const p = points[i];
          const x = x0 + ((p.t - t0) / (t1 - t0)) * pw;
          const y = yToPx(p.y, frame);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();

        ctx.fillStyle = stroke;
        ctx.globalAlpha = Math.min(1, alpha + 0.08);
        for(const p of points){
          const x = x0 + ((p.t - t0) / (t1 - t0)) * pw;
          const y = yToPx(p.y, frame);
          ctx.fillRect(Math.round(x)-1, Math.round(y)-1, 2, 2);
        }

        ctx.restore();
      }

      function drawLegend(frame){
        const { x0, y0 } = frame;
        ctx.save();
        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";

        const items = [
          { label:"Systolic",  stroke:"rgba(170,210,255,1)", alpha:0.95 },
          { label:"Diastolic", stroke:"rgba(235,245,255,1)", alpha:0.80 },
          { label:"Heart Rate",stroke:"rgba(150,255,210,1)", alpha:0.70 }
        ];

        let lx = x0 + 8;
        let ly = y0 + 6;
        for(const it of items){
          ctx.fillStyle = "rgba(235,245,255,.72)";
          ctx.strokeStyle = it.stroke;
          ctx.globalAlpha = it.alpha;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(lx, ly+7);
          ctx.lineTo(lx+16, ly+7);
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.fillText(it.label, lx+22, ly);
          ly += 18;
        }
        ctx.restore();
      }

      function renderCharts(){
        if(!ctx) return;
        clearCanvas();

        if(!records.length){
          chartsTopNote.textContent = "No records detected (read-only).";
          return;
        }

        ensureViewCenter();
        const range = getVisibleRange();
        if(!range.ok){
          chartsTopNote.textContent = "Records found, but no valid timestamps detected.";
          return;
        }

        const { t0, t1 } = range;

        const frame = drawPlotFrame();
        drawAlternatingDays(frame, t0, t1);
        drawSystolicBands(frame);
        drawYGridAndLabels(frame);
        drawXLabels(frame, t0, t1);

        const series = buildSeriesVisible(t0, t1);
        plotLine(series.sys, frame, t0, t1, "rgba(170,210,255,1)", 0.95);
        plotLine(series.dia, frame, t0, t1, "rgba(235,245,255,1)", 0.78);
        plotLine(series.hr,  frame, t0, t1, "rgba(150,255,210,1)", 0.72);

        drawLegend(frame);

        chartsTopNote.textContent = `${fmtCTDateOnly(t0)} \u2192 ${fmtCTDateOnly(t1)} (CT)`;
      }

      // Touch interactions on chart
      let gesture = {
        mode:null,
        startX:0,
        startCenter:0,
        startDays:7,
        pinchStartDist:0,
        pinchAnchorTime:0
      };

      function touchDist(a,b){
        const dx = a.clientX - b.clientX;
        const dy = a.clientY - b.clientY;
        return Math.hypot(dx, dy);
      }

      function onChartTouchStart(e){
        if(!records.length) return;
        setupCanvas();
        ensureViewCenter();

        if(e.touches.length === 1){
          gesture.mode = "pan";
          gesture.startX = e.touches[0].clientX;
          gesture.startCenter = view.centerMs ?? Date.now();
        } else if(e.touches.length === 2){
          gesture.mode = "pinch";
          const a = e.touches[0], b = e.touches[1];
          gesture.pinchStartDist = Math.max(1, touchDist(a,b));
          gesture.startDays = view.windowDays;

          const { t0, t1, ok } = getVisibleRange();
          if(ok){
            const rect = canvasWrap.getBoundingClientRect();
            const midX = (a.clientX + b.clientX) / 2;
            const x = clamp(midX - rect.left, 0, rect.width);
            const frac = rect.width > 0 ? (x / rect.width) : 0.5;
            gesture.pinchAnchorTime = t0 + frac * (t1 - t0);
          } else {
            gesture.pinchAnchorTime = view.centerMs;
          }
        }
        e.preventDefault();
      }

      function onChartTouchMove(e){
        if(!records.length || !gesture.mode) return;

        const range = getVisibleRange();
        if(!range.ok) return;

        if(gesture.mode === "pan" && e.touches.length === 1){
          const x = e.touches[0].clientX;
          const dx = x - gesture.startX;

          const rect = canvasWrap.getBoundingClientRect();
          const pxSpan = Math.max(1, rect.width);
          const timeSpan = (range.t1 - range.t0);
          const dt = (dx / pxSpan) * timeSpan;

          view.centerMs = clamp(gesture.startCenter - dt, view.tMinData, view.tMaxData);
          renderCharts();
        }

        if(gesture.mode === "pinch" && e.touches.length === 2){
          const a = e.touches[0], b = e.touches[1];
          const dist = Math.max(1, touchDist(a,b));

          // Spread apart => zoom in (fewer days). Pinch together => zoom out (more days).
          const scale = dist / gesture.pinchStartDist;
          const newDays = clamp(gesture.startDays / scale, view.minDays, view.maxDays);
          view.windowDays = newDays;

          const rect = canvasWrap.getBoundingClientRect();
          const midX = (a.clientX + b.clientX) / 2;
          const x = clamp(midX - rect.left, 0, rect.width);
          const frac = rect.width > 0 ? (x / rect.width) : 0.5;

          const wMs = view.windowDays * MS_DAY;
          view.centerMs = gesture.pinchAnchorTime - wMs * (frac - 0.5);
          view.centerMs = clamp(view.centerMs, view.tMinData, view.tMaxData);

          renderCharts();
        }

        e.preventDefault();
      }

      function onChartTouchEnd(e){
        if(e.touches.length === 0){
          gesture.mode = null;
        } else if(e.touches.length === 1){
          gesture.mode = "pan";
          gesture.startX = e.touches[0].clientX;
          gesture.startCenter = view.centerMs ?? gesture.startCenter;
        }
        e.preventDefault();
      }

      canvasWrap.addEventListener("touchstart", onChartTouchStart, {passive:false});
      canvasWrap.addEventListener("touchmove", onChartTouchMove, {passive:false});
      canvasWrap.addEventListener("touchend", onChartTouchEnd, {passive:false});
      canvasWrap.addEventListener("touchcancel", onChartTouchEnd, {passive:false});

      const ro = new ResizeObserver(()=>{
        if(panelCharts.classList.contains("active")){
          setupCanvas();
          renderCharts();
        }
      });
      ro.observe(canvasWrap);

      async function loadReadOnlyData(){
        const bridge = window.StorageBridge || window.VTStorage || window.storageBridge || null;

        if(!bridge){
          bridgeStatus.textContent = "Storage bridge not loaded. Check: ./js/storage.js";
          summary = { source:"Not loaded", entries:0, newest:null };
          records = [];
          renderSummary();
          renderLog(true);
          setupCanvas();
          renderCharts();
          return;
        }

        bridgeStatus.textContent = "Storage bridge loaded.";

        let out = null;
        const tryCalls = [
          () => bridge.detect && bridge.detect(),
          () => bridge.detectLegacy && bridge.detectLegacy(),
          () => bridge.inspect && bridge.inspect(),
          () => bridge.readOnlyScan && bridge.readOnlyScan(),
          () => bridge.getSummary && bridge.getSummary()
        ];

        for(const fn of tryCalls){
          try{
            const v = fn();
            out = (v && typeof v.then === "function") ? await v : v;
            if(out) break;
          }catch(_){}
        }

        let recs = null;
        const tryRecs = [
          () => bridge.getAll && bridge.getAll(),
          () => bridge.getRecords && bridge.getRecords(),
          () => bridge.readAll && bridge.readAll(),
          () => bridge.records && bridge.records()
        ];

        for(const fn of tryRecs){
          try{
            const v = fn();
            recs = (v && typeof v.then === "function") ? await v : v;
            if(Array.isArray(recs)) break;
          }catch(_){}
        }

        if(!Array.isArray(recs) && out && Array.isArray(out.records)) recs = out.records;
        if(!Array.isArray(recs)) recs = [];

        records = recs;

        // Dynamic Y scale (global, based on DB max systolic)
        Y_MAX = computeGlobalYMaxFromDB();
        SYS_BANDS = rebuildBands();

        let source = (out && (out.source || out.storage || out.kind)) || "localStorage";
        let entries = (out && (out.entries ?? out.count)) ?? records.length;

        let newest = (out && (out.newest || out.latest || out.newestISO)) || null;
        if(!newest && records.length){
          const newestMs = Math.max(...records.map(r => new Date(extractTs(r) || 0).getTime()).filter(Number.isFinite));
          if(Number.isFinite(newestMs) && newestMs > 0) newest = new Date(newestMs).toISOString();
        }

        summary = { source, entries, newest };
        renderSummary();

        view.windowDays = 7;
        view.centerMs = null;
        const b = computeDataTimeBounds();
        view.tMinData = b.tMin;
        view.tMaxData = b.tMax;

        renderLog(true);
        setupCanvas();
        renderCharts();
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("bootText").textContent = "BOOT OK " + APP_VERSION;
        loadReadOnlyData();
      });

    })();
  </script>
</body>
</html>
<!--
EOF File: index.html
Copyright (c) 2026 Wendell K. Jiles. All rights reserved.
App Version: v2.020
Reference: See header block for full change log + element IDs + dependency paths.
-->
