<!-- ===========================
File: /index.html
Vitals Tracker — Function-First Shell
App Version: v2.015
Base: v2.014

Changes in v2.015 (requested)
1) Fixed (non-fluctuating) Y-axis:
   - BP: 0–220 mmHg
   - HR: 40–160 bpm (separate scale)
2) Crisp canvas rendering using devicePixelRatio (no blur)
No storage changes. No UI restructuring.
=========================== -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#0b1324" />
  <title>Vitals Tracker</title>

  <style>
    :root{
      --bg0:#08101f;
      --bg1:#0b1324;
      --panel:#0c1528cc;
      --stroke:rgba(235,245,255,.16);
      --stroke2:rgba(235,245,255,.22);
      --strokeBold:rgba(180,210,255,.42);
      --text:rgba(235,245,255,.88);
      --muted:rgba(235,245,255,.58);
      --muted2:rgba(235,245,255,.42);
      --accent:#2b4e7a;
      --shadow:0 18px 42px rgba(0,0,0,.45);
      --r:22px;
      --r2:26px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(70,140,255,.20), transparent 60%),
        radial-gradient(900px 600px at 90% 10%, rgba(80,160,255,.12), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow:hidden;
      touch-action: manipulation;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding:14px 12px calc(14px + env(safe-area-inset-bottom));
      gap:12px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      border:1px solid var(--stroke2);
      border-radius:999px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
    }
    .title{font-weight:800; letter-spacing:.2px; font-size:22px;}
    .boot{font-size:13px; color:var(--muted); letter-spacing:.25px; white-space:nowrap;}

    .shell{
      flex:1;
      min-height:0;
      border:2px solid rgba(60,120,210,.55);
      border-radius: var(--r2);
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .panels{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow:hidden;
    }
    .panel{
      height:100%;
      display:none;
      flex-direction:column;
      gap:12px;
      overflow:hidden;
    }
    .panel.active{display:flex}

    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid var(--stroke2);
      border-radius:999px;
      padding:12px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .panelHeader .name{font-size:18px; font-weight:800; letter-spacing:.2px;}

    .nav{display:flex; gap:8px;}
    .btn{
      border:1px solid var(--stroke2);
      color:var(--text);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border-radius:999px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active{transform: translateY(1px)}
    .btn.secondary{
      color:var(--muted);
      border-color:var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      font-weight:700;
    }
    .btn.primary{
      border-color: rgba(120,180,255,.45);
      background: linear-gradient(180deg, rgba(80,150,255,.34), rgba(80,150,255,.14));
    }
    .btn[disabled]{opacity:.55; cursor:not-allowed}

    .card{
      border:1px solid var(--stroke2);
      border-radius: var(--r);
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      overflow:auto;
      min-height:0;
    }
    .muted{color:var(--muted)}
    .small{font-size:13px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

    .kv{
      display:grid;
      grid-template-columns: 110px 1fr;
      gap:8px 12px;
      margin-top:10px;
      font-size:15px;
    }
    .kv .k{color:var(--muted)}
    .kv .v{color:var(--text); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .list{
      margin:0;
      padding:0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:10px 12px;
      background: rgba(0,0,0,.18);
    }
    .rowTop{display:flex; justify-content:space-between; gap:10px; font-weight:800;}
    .rowSub{margin-top:6px; color:var(--muted); font-size:13px; line-height:1.25}
    .pill{
      padding:4px 10px;
      border-radius:999px;
      border:1px solid var(--stroke2);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }

    .canvasWrap{
      border:1px solid var(--stroke2);
      border-radius: var(--r);
      padding:10px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
      touch-action: none; /* chart captures gestures */
    }
    /* IMPORTANT: canvas size is controlled by CSS; JS makes buffer match DPR */
    canvas{display:block; width:100%; height:440px;}

    .hint{margin-top:10px; color:var(--muted); line-height:1.35;}

    .pull{
      height:0px;
      overflow:hidden;
      transition:height .18s ease;
      color:var(--muted);
      font-weight:800;
      letter-spacing:.2px;
      text-align:center;
    }

    .loadMoreWrap{margin-top:12px; display:flex; justify-content:center;}
    .linkBtn{
      border:1px solid var(--stroke2);
      border-radius:999px;
      padding:10px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text);
      font-weight:900;
      letter-spacing:.2px;
    }
    .linkBtn:active{transform:translateY(1px)}
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="title">Vitals Tracker</div>
      <div class="boot" id="bootText">BOOT OK v2.015</div>
    </div>

    <div class="shell">
      <div class="panels" id="panelsRoot">

        <!-- HOME PANEL -->
        <section class="panel active" id="panelHome" aria-label="Home">
          <div class="panelHeader">
            <div class="name">Home</div>
            <div class="nav">
              <button class="btn secondary" id="btnHome">Home</button>
              <button class="btn secondary" id="btnLog">Log</button>
              <button class="btn secondary" id="btnCharts">Charts</button>
              <button class="btn primary" id="btnInstall" disabled>Install</button>
            </div>
          </div>

          <div class="pull" id="pullIndicator">Release to refresh</div>

          <div class="card" id="homeCard">
            <div class="muted">Function-first shell. Data detection is read-only.</div>
            <div class="hint small">
              Pull down on Home to refresh (release).
              <div id="bridgeStatus" class="small" style="margin-top:10px;"></div>
            </div>

            <div class="card" style="margin-top:12px;" id="detectedCard">
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div style="font-weight:900; font-size:20px;">Data Detected (Read-Only)</div>
                <span class="pill" id="detectedPill">—</span>
              </div>
              <div class="kv" aria-label="Data summary">
                <div class="k">Source</div><div class="v" id="sumSource">Not loaded</div>
                <div class="k">Entries</div><div class="v" id="sumEntries">—</div>
                <div class="k">Newest</div><div class="v mono" id="sumNewest">—</div>
              </div>
            </div>
          </div>
        </section>

        <!-- LOG PANEL -->
        <section class="panel" id="panelLog" aria-label="Log">
          <div class="panelHeader">
            <div class="name">Log (read-only preview)</div>
            <div class="nav">
              <button class="btn secondary" id="btnBackFromLog">Home</button>
              <button class="btn secondary" id="btnChartsFromLog">Charts</button>
            </div>
          </div>

          <div class="card" id="logCard">
            <div class="muted" id="logTopNote">Loading…</div>
            <ul class="list" id="logList" style="margin-top:12px;"></ul>
            <div class="loadMoreWrap" id="logMoreWrap" style="display:none;">
              <button class="linkBtn" id="btnLoadMore">Load next 25</button>
            </div>
          </div>
        </section>

        <!-- CHARTS PANEL -->
        <section class="panel" id="panelCharts" aria-label="Charts">
          <div class="panelHeader">
            <div class="name">Charts (Read-Only)</div>
            <div class="nav">
              <button class="btn secondary" id="btnBackFromCharts">Home</button>
              <button class="btn secondary" id="btnLogFromCharts">Log</button>
            </div>
          </div>

          <div class="card" id="chartsCard">
            <div class="muted" id="chartsTopNote">Loading…</div>
            <div class="canvasWrap" style="margin-top:12px;">
              <canvas id="chartCanvas"></canvas>
            </div>
            <div class="hint small" id="chartsHint">
              Default window: 7 days. Adjust 2–14 days. Pan left/right. Pinch horizontally only. Central Time axis.
              Y-axes are fixed: BP 0–220, HR 40–160. Hypertension bands shown behind plot.
            </div>
          </div>
        </section>

      </div>
    </div>
  </div>

  <!-- External modules -->
  <script src="./js/storage.js?v=2.015"></script>
  <script src="./js/gestures.js?v=2.015"></script>

  <script>
    (function(){
      const APP_VERSION = "v2.015";
      const CT_TZ = "America/Chicago";

      // Fixed axes (stable interpretation)
      const BP_MIN = 0, BP_MAX = 220;
      const HR_MIN = 40, HR_MAX = 160;

      // Panels
      const panelHome = document.getElementById("panelHome");
      const panelLog = document.getElementById("panelLog");
      const panelCharts = document.getElementById("panelCharts");

      function showPanel(which){
        panelHome.classList.remove("active");
        panelLog.classList.remove("active");
        panelCharts.classList.remove("active");
        if(which === "home") panelHome.classList.add("active");
        if(which === "log") panelLog.classList.add("active");
        if(which === "charts") panelCharts.classList.add("active");
        if(which === "charts") ensureCanvasCrisp();
      }

      // Buttons
      const btnHome = document.getElementById("btnHome");
      const btnLog = document.getElementById("btnLog");
      const btnCharts = document.getElementById("btnCharts");
      const btnInstall = document.getElementById("btnInstall");

      document.getElementById("btnBackFromLog").onclick = () => showPanel("home");
      document.getElementById("btnChartsFromLog").onclick = () => showPanel("charts");
      document.getElementById("btnBackFromCharts").onclick = () => showPanel("home");
      document.getElementById("btnLogFromCharts").onclick = () => showPanel("log");

      btnHome.onclick = () => showPanel("home");
      btnLog.onclick = () => showPanel("log");
      btnCharts.onclick = () => showPanel("charts");

      // Pull-to-refresh (Home only)
      const pullIndicator = document.getElementById("pullIndicator");
      let pullStartY = null;
      let pullArmed = false;

      panelHome.addEventListener("touchstart", (e) => {
        const homeCard = document.getElementById("homeCard");
        if(homeCard.scrollTop !== 0) return;
        pullStartY = e.touches[0].clientY;
        pullArmed = false;
      }, {passive:true});

      panelHome.addEventListener("touchmove", (e) => {
        if(pullStartY == null) return;
        const dy = e.touches[0].clientY - pullStartY;
        if(dy > 0){
          const h = Math.min(48, Math.floor(dy/2));
          pullIndicator.style.height = h + "px";
          pullArmed = (h >= 36);
        }
      }, {passive:true});

      panelHome.addEventListener("touchend", () => {
        if(pullStartY == null) return;
        const armed = pullArmed;
        pullStartY = null;
        pullArmed = false;
        pullIndicator.style.height = "0px";
        if(armed) location.reload();
      });

      // Install button
      let deferredPrompt = null;
      window.addEventListener("beforeinstallprompt", (e) => {
        e.preventDefault();
        deferredPrompt = e;
        btnInstall.disabled = false;
      });

      btnInstall.addEventListener("click", async () => {
        try{
          if(!deferredPrompt) return;
          deferredPrompt.prompt();
          await deferredPrompt.userChoice;
        } finally {
          deferredPrompt = null;
          btnInstall.disabled = true;
        }
      });

      // Service worker (cache-busted)
      if("serviceWorker" in navigator){
        navigator.serviceWorker.register("./sw.js?v=2.015").catch(()=>{});
      }

      // Storage + rendering
      const bridgeStatus = document.getElementById("bridgeStatus");
      const sumSource = document.getElementById("sumSource");
      const sumEntries = document.getElementById("sumEntries");
      const sumNewest = document.getElementById("sumNewest");
      const detectedPill = document.getElementById("detectedPill");

      const logTopNote = document.getElementById("logTopNote");
      const logList = document.getElementById("logList");
      const logMoreWrap = document.getElementById("logMoreWrap");
      const btnLoadMore = document.getElementById("btnLoadMore");

      const chartsTopNote = document.getElementById("chartsTopNote");
      const chartCanvas = document.getElementById("chartCanvas");
      const canvasWrap = chartCanvas.closest(".canvasWrap");
      let ctx = chartCanvas.getContext("2d");

      let records = [];
      let summary = { source:"Not loaded", entries:0, newest:null };

      // Log paging
      let logSortedNewestFirst = [];
      let logShown = 0;
      const LOG_PAGE = 25;

      // Chart window
      const DAY_MS = 24*60*60*1000;
      const MIN_DAYS = 2;
      const MAX_DAYS = 14;
      const DEFAULT_DAYS = 7;

      let dataMinT = 0;
      let dataMaxT = 0;

      let viewEndT = 0;
      let viewDays = DEFAULT_DAYS;

      // Gesture state
      let panning = false;
      let panStartX = 0;
      let panStartEndT = 0;

      let pinchActive = false;
      let pinchStartDist = 0;
      let pinchStartDays = DEFAULT_DAYS;
      let pinchCenterX = 0;
      let pinchCenterT = 0;

      // Central Time formatters
      const dtFull = new Intl.DateTimeFormat("en-US", {
        timeZone: CT_TZ,
        year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit",
        hour12:false
      });
      const dtMD = new Intl.DateTimeFormat("en-US", { timeZone: CT_TZ, month:"2-digit", day:"2-digit" });
      const dtHM = new Intl.DateTimeFormat("en-US", { timeZone: CT_TZ, hour:"2-digit", minute:"2-digit", hour12:false });
      const dtMDHM = new Intl.DateTimeFormat("en-US", { timeZone: CT_TZ, month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit", hour12:false });

      function fmtCT(ts){
        try{
          const d = new Date(ts);
          if(isNaN(d.getTime())) return String(ts || "");
          return dtFull.format(d);
        }catch(_){ return String(ts || ""); }
      }

      function safeNum(x){
        const n = Number(x);
        return Number.isFinite(n) ? n : null;
      }

      function extractTs(r){
        return r.ts || r.time || r.timestamp || r.date || r.createdAt || r.created_at || r.iso || null;
      }

      function extractBP(r){
        const sys = safeNum(r.sys ?? r.systolic ?? (r.bp && (r.bp.sys ?? r.bp.systolic)));
        const dia = safeNum(r.dia ?? r.diastolic ?? (r.bp && (r.bp.dia ?? r.bp.diastolic)));
        return { sys, dia };
      }

      function extractHR(r){
        const hr = safeNum(r.hr ?? r.heartRate ?? r.pulse ?? (r.vitals && (r.vitals.hr ?? r.vitals.pulse)));
        return hr;
      }

      function extractNotes(r){
        return (r.notes ?? r.note ?? r.symptomsNote ?? r.text ?? "").toString();
      }

      function renderSummary(){
        sumSource.textContent = summary.source || "—";
        sumEntries.textContent = String(summary.entries ?? "—");
        sumNewest.textContent = summary.newest ? fmtCT(summary.newest) : "—";
        detectedPill.textContent = summary.entries ? (summary.entries + " entries") : "—";
      }

      function buildLogOrder(){
        logSortedNewestFirst = [...records].sort((a,b)=>{
          const ta = new Date(extractTs(a) || 0).getTime();
          const tb = new Date(extractTs(b) || 0).getTime();
          return tb - ta;
        });
        logShown = 0;
      }

      function appendLogPage(){
        if(!logSortedNewestFirst.length){
          logTopNote.textContent = "No records detected (read-only).";
          logMoreWrap.style.display = "none";
          return;
        }

        const total = logSortedNewestFirst.length;
        const next = Math.min(total, logShown + LOG_PAGE);
        const slice = logSortedNewestFirst.slice(logShown, next);

        if(logShown === 0){
          logList.innerHTML = "";
        }

        for(const r of slice){
          const tsRaw = extractTs(r);
          const t = new Date(tsRaw || 0).getTime();
          const {sys,dia} = extractBP(r);
          const hr = extractHR(r);
          const notes = extractNotes(r);

          const bpText = (sys != null || dia != null) ? `${sys ?? "—"}/${dia ?? "—"}` : "—";
          const hrText = (hr != null) ? `HR ${hr}` : "—";
          const whenText = (Number.isFinite(t) && t > 0) ? fmtCT(t) : String(tsRaw || "—");

          const li = document.createElement("li");
          li.className = "row";

          const top = document.createElement("div");
          top.className = "rowTop";
          top.innerHTML = `<div>${bpText}</div><div class="pill">${hrText}</div>`;

          const sub = document.createElement("div");
          sub.className = "rowSub";
          const noteTrim = notes && notes.trim() ? ` • ${notes.trim().slice(0,140)}` : "";
          sub.textContent = `${whenText}${noteTrim}`;

          li.appendChild(top);
          li.appendChild(sub);
          logList.appendChild(li);
        }

        logShown = next;
        logTopNote.textContent = `Showing newest ${logShown} of ${total} records (read-only).`;

        if(logShown < total){
          logMoreWrap.style.display = "flex";
          btnLoadMore.textContent = `Load next ${Math.min(LOG_PAGE, total - logShown)}`;
        }else{
          logMoreWrap.style.display = "none";
        }
      }

      btnLoadMore.addEventListener("click", () => appendLogPage());

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

      function ensureViewBounds(){
        if(!dataMinT || !dataMaxT || dataMaxT <= dataMinT){
          viewEndT = 0;
          viewDays = DEFAULT_DAYS;
          return;
        }
        viewDays = clamp(viewDays, MIN_DAYS, MAX_DAYS);
        const windowMs = viewDays * DAY_MS;
        const minEnd = dataMinT + windowMs;
        const maxEnd = dataMaxT;
        viewEndT = clamp(viewEndT || dataMaxT, minEnd, maxEnd);
      }

      function viewStartT(){ return viewEndT - (viewDays * DAY_MS); }

      function ensureCanvasCrisp(){
        // Make canvas buffer match CSS size * devicePixelRatio for sharp rendering
        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        const rect = chartCanvas.getBoundingClientRect();
        const cssW = Math.max(1, Math.round(rect.width));
        const cssH = Math.max(1, Math.round(rect.height));

        const wantW = cssW * dpr;
        const wantH = cssH * dpr;

        if(chartCanvas.width !== wantW || chartCanvas.height !== wantH){
          chartCanvas.width = wantW;
          chartCanvas.height = wantH;
          ctx = chartCanvas.getContext("2d");
        }

        // Scale drawing to CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function clearCanvasCssSpace(){
        const rect = chartCanvas.getBoundingClientRect();
        ctx.clearRect(0,0,rect.width, rect.height);
      }

      function tToX(t, x0, pw){
        const s = viewStartT();
        const e = viewEndT;
        const dt = Math.max(1, e - s);
        return x0 + ((t - s) / dt) * pw;
      }

      function computeVisiblePoints(){
        const s = viewStartT();
        const e = viewEndT;

        const ptsSys = [];
        const ptsDia = [];
        const ptsHr  = [];

        for(const r of records){
          const tsRaw = extractTs(r);
          const t = new Date(tsRaw || 0).getTime();
          if(!Number.isFinite(t) || t <= 0) continue;
          if(t < s || t > e) continue;

          const {sys,dia} = extractBP(r);
          const hr = extractHR(r);

          if(sys != null) ptsSys.push({t, y: sys});
          if(dia != null) ptsDia.push({t, y: dia});
          if(hr != null)  ptsHr.push({t, y: hr});
        }

        ptsSys.sort((a,b)=>a.t-b.t);
        ptsDia.sort((a,b)=>a.t-b.t);
        ptsHr.sort((a,b)=>a.t-b.t);

        return { ptsSys, ptsDia, ptsHr };
      }

      function yPixBP(val, y0, ph){
        const den = Math.max(1, (BP_MAX - BP_MIN));
        return y0 + (1 - ((val - BP_MIN)/den)) * ph;
      }
      function yPixHR(val, y0, ph){
        const den = Math.max(1, (HR_MAX - HR_MIN));
        return y0 + (1 - ((val - HR_MIN)/den)) * ph;
      }

      function drawHypertensionBands(x0, y0, pw, ph){
        // bands based on systolic thresholds, drawn on BP axis space
        const bands = [
          { a: 180, b: BP_MAX, label: "Crisis ≥180", fill:"rgba(255,255,255,.08)" },
          { a: 140, b: 179.999, label: "Stage 2 140–179", fill:"rgba(255,255,255,.06)" },
          { a: 130, b: 139.999, label: "Stage 1 130–139", fill:"rgba(255,255,255,.045)" },
          { a: 120, b: 129.999, label: "Elevated 120–129", fill:"rgba(255,255,255,.032)" },
          { a: BP_MIN, b: 119.999, label: "Normal <120", fill:"rgba(255,255,255,.02)" },
        ];

        ctx.save();
        ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";

        for(const band of bands){
          const top = yPixBP(band.b, y0, ph);
          const bot = yPixBP(band.a, y0, ph);
          const yA = Math.min(top, bot);
          const yB = Math.max(top, bot);
          const h = yB - yA;
          if(h <= 1) continue;

          ctx.fillStyle = band.fill;
          ctx.fillRect(x0, yA, pw, h);

          if(h >= 22){
            ctx.fillStyle = "rgba(235,245,255,.38)";
            ctx.fillText(band.label, x0 + 10, yA + 16);
          }
        }

        ctx.restore();
      }

      function chooseTickMs(days){
        const H = 60*60*1000;
        if(days <= 2.25) return 2*H;
        if(days <= 4.25) return 4*H;
        if(days <= 7.25) return 6*H;
        if(days <= 10.5) return 8*H;
        return 12*H;
      }

      function drawAxes(){
        const rect = chartCanvas.getBoundingClientRect();
        const w = Math.max(1, rect.width);
        const h = Math.max(1, rect.height);

        const padL = 78, padR = 78, padT = 16, padB = 78;
        const x0 = padL, y0 = padT, pw = w - padL - padR, ph = h - padT - padB;

        // bands behind
        drawHypertensionBands(x0, y0, pw, ph);

        // plot border
        ctx.strokeStyle = "rgba(235,245,255,.14)";
        ctx.lineWidth = 1.5;
        ctx.strokeRect(x0, y0, pw, ph);

        // horizontal grids for BP (left labels)
        ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillStyle = "rgba(235,245,255,.55)";
        ctx.strokeStyle = "rgba(235,245,255,.10)";
        ctx.lineWidth = 1;

        const bpTicks = [0,50,100,120,140,160,180,200,220];
        for(const v of bpTicks){
          const y = yPixBP(v, y0, ph);
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x0+pw, y);
          ctx.stroke();
          ctx.fillText(String(v), 12, y + 6);
        }
        // label left axis
        ctx.fillStyle = "rgba(235,245,255,.42)";
        ctx.fillText("BP (mmHg)", 12, y0 - 2);

        // HR ticks on right (separate scale, no grid lines to reduce clutter)
        ctx.fillStyle = "rgba(235,245,255,.46)";
        const hrTicks = [40,60,80,100,120,140,160];
        for(const v of hrTicks){
          const y = yPixHR(v, y0, ph);
          ctx.fillText(String(v), x0+pw+12, y + 6);
        }
        ctx.fillText("HR (bpm)", x0+pw+12, y0 - 2);

        // x ticks (dynamic)
        const start = viewStartT();
        const end = viewEndT;
        const tickMs = chooseTickMs(viewDays);

        const maxLabels = 9;
        const span = Math.max(1, end - start);
        const ideal = Math.ceil(span / tickMs);
        const labelEvery = Math.max(1, Math.ceil(ideal / maxLabels));

        let firstTick = Math.ceil(start / tickMs) * tickMs;

        const fontSize = (viewDays <= 3) ? 16 : (viewDays <= 7 ? 15 : 14);
        ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = "rgba(235,245,255,.55)";
        ctx.strokeStyle = "rgba(235,245,255,.08)";
        ctx.lineWidth = 1;

        let idx = 0;
        for(let tt = firstTick; tt <= end; tt += tickMs){
          const x = x0 + ((tt - start) / span) * pw;

          // tick mark
          ctx.beginPath();
          ctx.moveTo(x, y0+ph);
          ctx.lineTo(x, y0+ph+8);
          ctx.stroke();

          // faint vertical
          ctx.strokeStyle = "rgba(235,245,255,.05)";
          ctx.beginPath();
          ctx.moveTo(x, y0);
          ctx.lineTo(x, y0+ph);
          ctx.stroke();
          ctx.strokeStyle = "rgba(235,245,255,.08)";

          if(idx % labelEvery === 0){
            const d = new Date(tt);
            const label = (viewDays <= 2.25) ? dtHM.format(d) : dtMDHM.format(d);
            ctx.fillText(label, x - (label.length * (fontSize * 0.28)), y0+ph+28);
          }
          idx++;
        }

        // window label
        ctx.fillStyle = "rgba(235,245,255,.55)";
        const winLabel = `${dtMD.format(new Date(start))} → ${dtMD.format(new Date(end))}  (${viewDays.toFixed(1)} days)`;
        ctx.fillText(winLabel, x0, y0+ph+56);

        return { x0, y0, pw, ph, w, h };
      }

      function plotBP(points, axis, style){
        if(points.length < 2) return;
        ctx.save();
        ctx.strokeStyle = style;
        ctx.fillStyle = style;
        ctx.lineWidth = 2.5;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        const start = viewStartT();
        const end = viewEndT;
        const span = Math.max(1, end - start);

        ctx.beginPath();
        const xA = axis.x0 + ((points[0].t - start)/span)*axis.pw;
        const yA = yPixBP(points[0].y, axis.y0, axis.ph);
        ctx.moveTo(xA, yA);

        for(let i=1;i<points.length;i++){
          const x = axis.x0 + ((points[i].t - start)/span)*axis.pw;
          const y = yPixBP(points[i].y, axis.y0, axis.ph);
          ctx.lineTo(x, y);
        }
        ctx.stroke();

        for(const p of points){
          const x = axis.x0 + ((p.t - start)/span)*axis.pw;
          const y = yPixBP(p.y, axis.y0, axis.ph);
          ctx.beginPath();
          ctx.arc(x, y, 3.5, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.restore();
      }

      function plotHR(points, axis, style){
        if(points.length < 2) return;
        ctx.save();
        ctx.strokeStyle = style;
        ctx.fillStyle = style;
        ctx.lineWidth = 2.0;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        const start = viewStartT();
        const end = viewEndT;
        const span = Math.max(1, end - start);

        ctx.beginPath();
        const xA = axis.x0 + ((points[0].t - start)/span)*axis.pw;
        const yA = yPixHR(points[0].y, axis.y0, axis.ph);
        ctx.moveTo(xA, yA);

        for(let i=1;i<points.length;i++){
          const x = axis.x0 + ((points[i].t - start)/span)*axis.pw;
          const y = yPixHR(points[i].y, axis.y0, axis.ph);
          ctx.lineTo(x, y);
        }
        ctx.stroke();

        for(const p of points){
          const x = axis.x0 + ((p.t - start)/span)*axis.pw;
          const y = yPixHR(p.y, axis.y0, axis.ph);
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.restore();
      }

      function renderCharts(){
        if(!records.length){
          chartsTopNote.textContent = "No records detected (read-only).";
          return;
        }
        if(!dataMinT || !dataMaxT){
          chartsTopNote.textContent = "Records found, but timestamps could not be parsed.";
          return;
        }

        ensureViewBounds();
        ensureCanvasCrisp();
        clearCanvasCssSpace();

        const axis = drawAxes();
        const { ptsSys, ptsDia, ptsHr } = computeVisiblePoints();

        // plot series with stable style choices
        plotBP(ptsSys, axis, "rgba(130,190,255,.92)");
        plotBP(ptsDia, axis, "rgba(130,190,255,.62)");
        plotHR(ptsHr, axis, "rgba(130,190,255,.40)");

        const s = viewStartT();
        const e = viewEndT;
        chartsTopNote.textContent =
          `CT view: ${dtMDHM.format(new Date(s))} → ${dtMDHM.format(new Date(e))} • Window ${viewDays.toFixed(1)} days • Total records ${records.length} (read-only).`;
      }

      function setDefaultChartWindowToLatest(){
        if(!dataMaxT) return;
        viewDays = DEFAULT_DAYS;
        viewEndT = dataMaxT;
        ensureViewBounds();
      }

      // ===== Chart gesture handling (chart only) =====
      function getCanvasClientRect(){ return chartCanvas.getBoundingClientRect(); }
      function dist2(a,b){
        const dx = a.clientX - b.clientX;
        const dy = a.clientY - b.clientY;
        return Math.sqrt(dx*dx + dy*dy);
      }

      function beginPan(clientX){
        panning = true;
        panStartX = clientX;
        panStartEndT = viewEndT;
      }

      function movePan(clientX){
        if(!panning) return;
        const rect = getCanvasClientRect();
        const w = Math.max(1, rect.width);
        const dx = clientX - panStartX;

        const windowMs = viewDays * DAY_MS;
        const dt = (dx / w) * windowMs;

        viewEndT = panStartEndT - dt;
        ensureViewBounds();
        renderCharts();
      }

      function endPan(){ panning = false; }

      function beginPinch(t1, t2){
        pinchActive = true;
        pinchStartDist = dist2(t1, t2);
        pinchStartDays = viewDays;

        const rect = getCanvasClientRect();
        const centerX = (t1.clientX + t2.clientX) / 2;
        pinchCenterX = centerX - rect.left;

        const wCss = Math.max(1, rect.width);
        const frac = clamp(pinchCenterX / wCss, 0, 1);
        pinchCenterT = viewStartT() + frac * (viewDays * DAY_MS);
      }

      function movePinch(t1, t2){
        if(!pinchActive) return;
        const d = dist2(t1, t2);
        const ratio = d / Math.max(1, pinchStartDist);

        let newDays = pinchStartDays / ratio;
        newDays = clamp(newDays, MIN_DAYS, MAX_DAYS);

        viewDays = newDays;

        const rect = getCanvasClientRect();
        const wCss = Math.max(1, rect.width);
        const frac = clamp(pinchCenterX / wCss, 0, 1);

        const winMs = viewDays * DAY_MS;
        viewEndT = pinchCenterT + (1 - frac) * winMs;

        ensureViewBounds();
        renderCharts();
      }

      function endPinch(){ pinchActive = false; }

      canvasWrap.addEventListener("touchstart", (e) => {
        if(!records.length) return;
        if(e.touches.length === 1){
          beginPan(e.touches[0].clientX);
        }else if(e.touches.length === 2){
          endPan();
          beginPinch(e.touches[0], e.touches[1]);
        }
      }, {passive:false});

      canvasWrap.addEventListener("touchmove", (e) => {
        if(!records.length) return;
        e.preventDefault();

        if(e.touches.length === 1 && !pinchActive){
          movePan(e.touches[0].clientX);
        }else if(e.touches.length === 2){
          if(!pinchActive) beginPinch(e.touches[0], e.touches[1]);
          movePinch(e.touches[0], e.touches[1]);
        }
      }, {passive:false});

      canvasWrap.addEventListener("touchend", (e) => {
        if(e.touches.length === 0){
          endPan();
          endPinch();
        }else if(e.touches.length === 1){
          endPinch();
          beginPan(e.touches[0].clientX);
        }
      }, {passive:true});

      // If screen rotates or layout changes, refresh crispness and redraw
      window.addEventListener("resize", () => {
        if(panelCharts.classList.contains("active")){
          ensureCanvasCrisp();
          renderCharts();
        }
      });

      async function loadReadOnlyData(){
        const bridge = window.StorageBridge || window.VTStorage || window.storageBridge || null;

        if(!bridge){
          bridgeStatus.textContent = "Storage bridge not loaded. Check: ./js/storage.js";
          summary = { source:"Not loaded", entries:0, newest:null };
          records = [];
          renderSummary();
          buildLogOrder();
          appendLogPage();
          renderCharts();
          return;
        }

        bridgeStatus.textContent = "Storage bridge loaded.";

        let out = null;
        const tryCalls = [
          () => bridge.detect && bridge.detect(),
          () => bridge.detectLegacy && bridge.detectLegacy(),
          () => bridge.inspect && bridge.inspect(),
          () => bridge.readOnlyScan && bridge.readOnlyScan(),
          () => bridge.getSummary && bridge.getSummary()
        ];

        for(const fn of tryCalls){
          try{
            const v = fn();
            out = (v && typeof v.then === "function") ? await v : v;
            if(out) break;
          }catch(_){}
        }

        let recs = null;
        const tryRecs = [
          () => bridge.getAll && bridge.getAll(),
          () => bridge.getRecords && bridge.getRecords(),
          () => bridge.readAll && bridge.readAll(),
          () => bridge.records && bridge.records()
        ];

        for(const fn of tryRecs){
          try{
            const v = fn();
            recs = (v && typeof v.then === "function") ? await v : v;
            if(Array.isArray(recs)) break;
          }catch(_){}
        }

        if(!Array.isArray(recs) && out && Array.isArray(out.records)) recs = out.records;
        if(!Array.isArray(recs)) recs = [];
        records = recs;

        const times = records.map(r => new Date(extractTs(r) || 0).getTime()).filter(t => Number.isFinite(t) && t > 0);
        dataMinT = times.length ? Math.min(...times) : 0;
        dataMaxT = times.length ? Math.max(...times) : 0;

        const source = (out && (out.source || out.storage || out.kind)) || "localStorage";
        const entries = (out && (out.entries ?? out.count)) ?? records.length;

        let newest = (out && (out.newest || out.latest || out.newestISO)) || null;
        if(!newest && dataMaxT) newest = dataMaxT;

        summary = { source, entries, newest };
        renderSummary();

        buildLogOrder();
        appendLogPage();

        if(dataMaxT){
          setDefaultChartWindowToLatest();
        }
        renderCharts();
      }

      document.addEventListener("DOMContentLoaded", () => {
        const boot = document.getElementById("bootText");
        if(boot) boot.textContent = "BOOT OK " + APP_VERSION;
        loadReadOnlyData();
      });

    })();
  </script>
</body>
</html>

<!-- ===========================
File: /index.html
End of file — v2.015
Element IDs intentionally preserved (stability contract)
- Panels: #panelHome #panelLog #panelCharts
- Home: #homeCard #bridgeStatus #sumSource #sumEntries #sumNewest #detectedPill
- Log: #logCard #logTopNote #logList #btnLoadMore #logMoreWrap
- Charts: #chartsCard #chartsTopNote #chartCanvas

External files expected
- /js/storage.js
- /js/gestures.js
- /sw.js
=========================== -->
