return s;
  }

  function fmtDateTime(ts){
    const d = new Date(ts);
    const mo = String(d.getMonth()+1).padStart(2,"0");
    const da = String(d.getDate()).padStart(2,"0");
    const yr = d.getFullYear();
    let hr = d.getHours();
    const ampm = hr>=12 ? "PM":"AM";
    hr = hr%12; if(hr===0) hr=12;
    const mi = String(d.getMinutes()).padStart(2,"0");
    const se = String(d.getSeconds()).padStart(2,"0");
    return `${mo}/${da}/${yr}, ${String(hr).padStart(2,"0")}:${mi}:${se} ${ampm}`;
  }

  function toDTLocalValue(ts){
    const d = new Date(ts);
    const pad = (n)=> String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  function fromDTLocalValue(v){
    if(!v) return Date.now();
    const d = new Date(v);
    const t = d.getTime();
    return Number.isFinite(t) ? t : Date.now();
  }

  function classifyPattern(numStr){
    const s = (numStr || "").replace(/\D/g,"");
    if(!s) return "—";

    const allSame = s.split("").every(ch => ch === s[0]);
    if(allSame) return `Repeating ${s[0]}s`;

    const isMirror = s.length>=4 && s === s.split("").reverse().join("");
    if(isMirror) return "Mirror / Palindrome";

    const pairs = s.length%2===0 && (() => {
      const half = s.length/2;
      return s.slice(0,half) === s.slice(half);
    })();
    if(pairs) return "Double pattern";

    // Simple sequences
    const asc = "01234567890123456789";
    const desc = "98765432109876543210";
    if(asc.includes(s)) return "Ascending sequence";
    if(desc.includes(s)) return "Descending sequence";

    // Alternating digits (e.g., 1212, 3434)
    const alt = s.length>=4 && s.split("").every((ch,i)=> ch === s[i%2]);
    if(alt) return "Alternating pattern";

    return "Mixed pattern";
  }

  function digitSum(numStr){
    const s = (numStr || "").replace(/\D/g,"");
    let sum = 0;
    for(const ch of s) sum += (ch.charCodeAt(0)-48);
    return sum;
  }

  function reduceToSingle(n){
    let x = Math.abs(Number(n)||0);
    while(x>9){
      let s=0;
      for(const ch of String(x)) s += (ch.charCodeAt(0)-48);
      x = s;
    }
    return x;
  }

  function buildAngelCard(numStr){
    const raw = (numStr || "").trim();
    const s = raw.replace(/\D/g,"");
    if(!s){
      return {
        number: raw,
        main: "—",
        patternNote: "—",
        meta: "Enter a number to generate an Angel Card."
      };
    }

    const pattern = classifyPattern(s);
    const ds = digitSum(s);
    const root = reduceToSingle(ds);

    // Base meanings by root digit (simple, stable, neutral)
    const rootThemes = {
      0: "Reset and openness. Start fresh. Let the next step reveal itself.",
      1: "Initiation and self-leadership. Choose a direction; take the first step.",
      2: "Balance and patience. Cooperate; keep the peace where you can.",
      3: "Expression and growth. Communicate; create; let encouragement in.",
      4: "Stability and structure. Build the foundation; handle the practical.",
      5: "Change and flexibility. Adapt; release what is stale; stay mobile.",
      6: "Care and responsibility. Support home/health; restore harmony.",
      7: "Insight and inner truth. Learn; reflect; trust your quiet knowing.",
      8: "Strength and momentum. Act with discipline; respect boundaries.",
      9: "Completion and compassion. Close a chapter; forgive; serve wisely."
    };

    const main = `Main theme: ${rootThemes[root] || rootThemes[2]}`;

    let patternNote = "";
    if(/^(\d)\1+$/.test(s)){
      const d = s[0];
      patternNote = `Pattern note: repeating digits turn up the volume on the main theme (${d}).`;
    }else if(pattern === "Double pattern"){
      patternNote = "Pattern note: double patterns suggest reinforcement—two signals echoing the same idea.";
    }else if(pattern === "Alternating pattern"){
      patternNote = "Pattern note: alternating digits often points to a back-and-forth choice or a rhythm to stabilize.";
    }else if(pattern === "Ascending sequence"){
      patternNote = "Pattern note: ascending sequences often point to progression—keep moving one step at a time.";
    }else if(pattern === "Descending sequence"){
      patternNote = "Pattern note: descending sequences often suggest simplifying—reduce pressure and return to basics.";
    }else if(pattern === "Mirror / Palindrome"){
      patternNote = "Pattern note: mirror patterns often reflect self-awareness—notice what you are projecting and receiving.";
    }else{
      patternNote = "Pattern note: mixed patterns often highlight the main theme in a less linear, more situational way.";
    }

    const meta =
      `Overview\n` +
      `${main}\n\n` +
      `Why this pattern matters\n` +
      `${patternNote}\n\n` +
      `Simple number lens (digit-sum)\n` +
      `Digits sum: ${ds}\n` +
      `Reduced: ${root} (interpretation anchor)\n\n` +
      `One small action\n` +
      `Pick a single action that fits the theme, and do it within 24 hours.`;

    return { number: s, main, patternNote, meta, pattern, ds, root };
  }

  function openInfo(title, text, opts={}){
    $("infoTitle").textContent = title || "Info";
    $("infoSub").textContent = text || "";
    $("addedBlock").classList.add("hidden");

    const ok = $("btnInfoOk");
    ok.textContent = opts.okText || "OK";
    ok.dataset.mode = opts.mode || "info";

    $("infoModal").classList.remove("hidden");
    lockTouch(true);
  }

  function closeInfo(){
    $("infoModal").classList.add("hidden");
    lockTouch(false);
  }

  // Export modal helpers
  function openExport(reportText){
    $("exportReportBox").textContent = reportText || "";
    $("exportModal").classList.remove("hidden");
    lockTouch(true);
  }
  function closeExport(){
    $("exportModal").classList.add("hidden");
    lockTouch(false);
  }

  // Touch lock
  function lockTouch(on){
    const el = $("touchLock");
    if(!el) return;
    el.classList.toggle("on", !!on);
  }

  // Deck swipe
  const deck = $("deck");
  let deckX = 0; // 0 = home, -50% = calendar
  let drag = null;

  function setDeck(pos, animate=true){
    deckX = pos;
    deck.classList.toggle("anim", !!animate);
    deck.style.transform = `translate3d(${deckX}%,0,0)`;
  }

  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

  function onDeckStart(e){
    if(e.touches && e.touches.length>1) return;
    if($("infoModal") && !$("infoModal").classList.contains("hidden")) return;
    if($("exportModal") && !$("exportModal").classList.contains("hidden")) return;
    if($("addCalModal") && !$("addCalModal").classList.contains("hidden")) return;
    if($("newSightingModal") && !$("newSightingModal").classList.contains("hidden")) return;
    if($("dayListModal") && !$("dayListModal").classList.contains("hidden")) return;
    if($("editModal") && !$("editModal").classList.contains("hidden")) return;

    const x = e.touches ? e.touches[0].clientX : e.clientX;
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    drag = { x0:x, y0:y, dx:0, dy:0, started:false };
  }

  function onDeckMove(e){
    if(!drag) return;
    const x = e.touches ? e.touches[0].clientX : e.clientX;
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    drag.dx = x - drag.x0;
    drag.dy = y - drag.y0;

    if(!drag.started){
      if(Math.abs(drag.dx) > 10 && Math.abs(drag.dx) > Math.abs(drag.dy)){
        drag.started = true;
        deck.classList.remove("anim");
      }else{
        return;
      }
    }

    e.preventDefault();
    const w = $("screenArea").clientWidth || 360;
    const deltaPct = (drag.dx / w) * 100;
    const next = clamp(deckX + deltaPct, -50, 0);
    deck.style.transform = `translate3d(${next}%,0,0)`;
  }

  function onDeckEnd(){
    if(!drag) return;
    if(!drag.started){
      drag = null;
      return;
    }
    const w = $("screenArea").clientWidth || 360;
    const pct = (drag.dx / w) * 100;
    const target = (deckX === 0)
      ? (pct < -15 ? -50 : 0)
      : (pct > 15 ? 0 : -50);

    setDeck(target, true);
    drag = null;
  }

  $("screenArea").addEventListener("touchstart", onDeckStart, {passive:true});
  $("screenArea").addEventListener("touchmove", onDeckMove, {passive:false});
  $("screenArea").addEventListener("touchend", onDeckEnd, {passive:true});
  $("screenArea").addEventListener("touchcancel", onDeckEnd, {passive:true});

  // Pull-to-refresh (home + calendar) lightweight
  const ptr = $("ptr");
  const ptrHint = $("ptrHint");
  const ptrSmall = $("ptrSmall");
  let ptrState = { pulling:false, startY:0, dist:0, target:null };

  function ptrAttach(scrollEl, label){
    scrollEl.addEventListener("touchstart",(e)=>{
      if(e.touches.length>1) return;
      if(scrollEl.scrollTop>0) return;
      ptrState = { pulling:true, startY:e.touches[0].clientY, dist:0, target:scrollEl };
      ptrHint.textContent = "Pull to refresh";
      ptrSmall.textContent = label || "";
      ptr.classList.add("show");
    }, {passive:true});

    scrollEl.addEventListener("touchmove",(e)=>{
      if(!ptrState.pulling) return;
      const y = e.touches[0].clientY;
      const d = Math.max(0, y - ptrState.startY);
      ptrState.dist = d;
      if(d > 78){
        ptrHint.textContent = "Release to refresh";
      }else{
        ptrHint.textContent = "Pull to refresh";
      }
    }, {passive:true});

    scrollEl.addEventListener("touchend",()=>{
      if(!ptrState.pulling) return;
      const doRefresh = ptrState.dist > 78;
      ptrState.pulling = false;
      ptr.classList.remove("show");
      if(doRefresh){
        // refresh calendar + home view content
        refreshAll();
        openInfo("Refreshed", "Updated the calendar and current view.", {mode:"info"});
      }
    }, {passive:true});
  }

  ptrAttach($("homeScroll"), "Home");
  ptrAttach($("calendar"), "Calendar");

  // Data
  let records = loadRecords();
  let currentCard = null;      // current Angel Card data
  let currentSelectedId = null; // selected record in edit modal
  let detailsShown = false;

  function refreshAll(){
    records = loadRecords();
    renderCalendar();
    updateFooterVersion();
    updateInstallButtons();
  }

  function updateFooterVersion(){
    const hv = $("homeVerLabel");
    if(hv) hv.textContent = APP_VERSION;
  }

  // HOME submit
  function doHomeSubmit(){
    const val = ($("homeIdNum").value || "").trim();
    const card = buildAngelCard(val);
    currentCard = card;

    $("homeAfterSubmit").classList.remove("hidden");
    $("homeAngelHeader").textContent = `Angel Card Number: ${card.number || "—"}`;
    $("homeAngelBigNum").textContent = card.number || "—";
    $("homeMeta").textContent = card.meta || "—";

    // update add-to-calendar modal defaults
    const now = Date.now();
    $("addCalDT").value = toDTLocalValue(now);
    $("addCalNumber").textContent = card.number || "—";
    $("addCalNotes").value = "";

    // set footer
    updateFooterVersion();

    // update install buttons availability/label
    updateInstallButtons();
  }

  $("btnHomeSubmit").addEventListener("click", doHomeSubmit);
  $("homeIdNum").addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      e.preventDefault();
      doHomeSubmit();
    }
  });

  // HOME actions
  $("btnViewCalendar").addEventListener("click", ()=> setDeck(-50,true));

  $("btnAddToCalendar").addEventListener("click", ()=>{
    if(!currentCard || !currentCard.number || currentCard.number === "—"){
      openInfo("No number", "Enter a number first.", {mode:"info"});
      return;
    }
    $("addCalModal").classList.remove("hidden");
    lockTouch(true);
  });

  // Install buttons (small + big)
  function handleInstallClick(btn){
    const mode = btn.dataset.mode || "install";
    if(mode === "uninstall"){
      uninstallGuidance();
      return;
    }
    tryInstallFlow();
  }

  $("btnInstall").addEventListener("click", (e)=> handleInstallClick(e.currentTarget));
  $("btnInstallBig").addEventListener("click", (e)=> handleInstallClick(e.currentTarget));

  $("btnExitHome").addEventListener("click", ()=>{
    // Known limitation: many browsers block window.close() unless opened by script.
    try{ window.close(); }catch{}
    setTimeout(()=>{
      openInfo("Exit", "If this did not close, use your back button or close the tab.", {mode:"info"});
    }, 260);
  });

  // HOME Export (Identify export)
  $("btnHomeExport").addEventListener("click", ()=>{
    if(!currentCard || !currentCard.number || currentCard.number === "—"){
      openInfo("Export", "Enter a number first, then Export.", {mode:"info"});
      return;
    }
    const report = buildIdentifyReport(currentCard.number);
    openExport(report);
  });

  // Calendar: back
  $("btnBackFromCalendar").addEventListener("click", ()=> setDeck(0,true));

  // Calendar month input
  function setMonthToNow(){
    const d = new Date();
    const m = String(d.getMonth()+1).padStart(2,"0");
    $("calMonth").value = `${d.getFullYear()}-${m}`;
  }

  // Calendar DOW headers
  function buildDowRow(){
    const names = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const row = $("calDowRow");
    row.innerHTML = "";
    for(const n of names){
      const div = document.createElement("div");
      div.className = "calDow";
      div.textContent = n;
      row.appendChild(div);
    }
  }

  function getMonthDays(yyyyMM){
    const [y,m] = yyyyMM.split("-").map(x=>parseInt(x,10));
    const first = new Date(y, m-1, 1);
    const startDow = first.getDay();
    const start = new Date(y, m-1, 1 - startDow);
    const cells = [];
    for(let i=0;i<42;i++){
      const d = new Date(start.getTime() + i*DAY_MS);
      const inMonth = (d.getMonth() === (m-1));
      cells.push({ date:d, inMonth });
    }
    return cells;
  }

  function ymd(d){
    const pad=(n)=>String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }

  function renderCalendar(){
    buildDowRow();
    const grid = $("calGrid");
    grid.innerHTML = "";
    const yyyyMM = $("calMonth").value || (()=>{ setMonthToNow(); return $("calMonth").value; })();

    // Build a quick index: ymd -> count
    const idx = new Map();
    for(const r of records){
      const d = new Date(r.ts);
      const key = ymd(d);
      idx.set(key, (idx.get(key)||0)+1);
    }

    const cells = getMonthDays(yyyyMM);
    for(const c of cells){
      const key = ymd(c.date);
      const count = idx.get(key)||0;

      const cell = document.createElement("div");
      cell.className = "calCell" + (count? " hasData":"") + (c.inMonth? "":" outMonth");
      cell.dataset.ymd = key;
      cell.innerHTML = `<div class="dnum">${c.date.getDate()}</div>` +
                       (count ? `<div style="font-size:12px;color:rgba(235,245,255,.70);font-weight:900;">${count} entry${count>1?"ies":"y"}</div>` : "");
      cell.addEventListener("click", ()=>{
        if(count){
          openDayList(key);
        }
      });
      grid.appendChild(cell);
    }
  }

  $("calMonth").addEventListener("change", renderCalendar);

  // Day list modal
  function openDayList(ymdKey){
    const items = records
      .filter(r => ymd(new Date(r.ts)) === ymdKey)
      .sort((a,b)=> a.ts - b.ts);

    $("dayListTitle").textContent = ymdKey;
    $("dayListSub").textContent = "Tap a number to view details.";

    $("dayLogoRow").innerHTML = $("dayLogoRow").innerHTML || document.querySelector(".logoTitle svg").outerHTML;

    const list = $("dayList");
    list.innerHTML = "";
    for(const r of items){
      const row = document.createElement("div");
      row.className = "dayItem";
      const d = new Date(r.ts);
      let hr = d.getHours();
      const ampm = hr>=12 ? "PM":"AM";
      hr = hr%12; if(hr===0) hr=12;
      const mi = String(d.getMinutes()).padStart(2,"0");
      const time = `${String(hr).padStart(2,"0")}:${mi} ${ampm}`;
      row.innerHTML =
        `<div class="dayLeft">
           <div class="dayTime">${time}</div>
           <div class="dayNum">${escapeHtml(r.number)}</div>
         </div>
         <div class="dayNotes">${escapeHtml(r.notes || "")}</div>
         <div class="chev">›</div>`;
      row.addEventListener("click", ()=>{
        $("dayListModal").classList.add("hidden");
        openEdit(r.id);
      });
      list.appendChild(row);
    }

    $("dayListModal").classList.remove("hidden");
    lockTouch(true);
  }

  $("btnDayListClose").addEventListener("click", ()=>{
    $("dayListModal").classList.add("hidden");
    lockTouch(false);
  });

  // Calendar add new
  $("btnCalAddNew").addEventListener("click", ()=>{
    const now = Date.now();
    $("newSightingDT").value = toDTLocalValue(now);
    $("newSightingNum").value = "";
    $("newSightingNotes").value = "";
    $("newSightingModal").classList.remove("hidden");
    lockTouch(true);
  });
  $("btnNewSightingX").addEventListener("click", ()=>{
    $("newSightingModal").classList.add("hidden");
    lockTouch(false);
  });
  $("btnNewSightingCancel").addEventListener("click", ()=>{
    $("newSightingModal").classList.add("hidden");
    lockTouch(false);
  });

  $("btnNewSightingAdd").addEventListener("click", ()=>{
    const ts = fromDTLocalValue($("newSightingDT").value);
    const num = ($("newSightingNum").value || "").trim();
    const card = buildAngelCard(num);
    const rec = {
      id: makeId(ts),
      ts,
      number: card.number || num,
      pattern: card.pattern || classifyPattern(card.number || num),
      meaning: card.meta || "",
      notes: ($("newSightingNotes").value || "").trim()
    };
    addRecord(rec);
    $("newSightingModal").classList.add("hidden");
    lockTouch(false);
    renderCalendar();
    openInfo("Added", "Saved to Calendar.", {mode:"info"});
  });

  // Add-to-calendar modal from Home
  $("btnAddCalX").addEventListener("click", ()=>{
    $("addCalModal").classList.add("hidden");
    lockTouch(false);
  });
  $("btnAddCalCancel").addEventListener("click", ()=>{
    $("addCalModal").classList.add("hidden");
    lockTouch(false);
  });

  $("btnAddCalAdd").addEventListener("click", ()=>{
    if(!currentCard || !currentCard.number || currentCard.number === "—"){
      openInfo("No number", "Enter a number first.", {mode:"info"});
      return;
    }
    const ts = fromDTLocalValue($("addCalDT").value);
    const notes = ($("addCalNotes").value || "").trim();
    const rec = {
      id: makeId(ts),
      ts,
      number: currentCard.number,
      pattern: currentCard.pattern || classifyPattern(currentCard.number),
      meaning: currentCard.meta || "",
      notes
    };
    addRecord(rec);
    $("addCalModal").classList.add("hidden");
    lockTouch(false);
    renderCalendar();
    openInfo("Added", "Saved to Calendar.", {mode:"info"});
  });

  // Edit modal
  function openEdit(id){
    const rec = records.find(r=>r.id===id);
    if(!rec){
      openInfo("Not found", "That entry could not be found.", {mode:"info"});
      return;
    }

    currentSelectedId = rec.id;
    detailsShown = false;
    $("editDetailsBox").classList.add("hidden");
    $("btnToggleDetails").textContent = "View/Edit Details";

    const card = buildAngelCard(rec.number);
    $("editAngelHeader").textContent = `Angel Card Number: ${card.number || rec.number || "—"}`;
    $("editAngelBig").textContent = card.number || rec.number || "—";
    $("editAngelCard").textContent = card.meta || rec.meaning || "—";

    $("editDT").value = toDTLocalValue(rec.ts);
    $("editNum").value = rec.number || "";
    $("editNotes").value = rec.notes || "";
    $("editPattern").textContent = rec.pattern || card.pattern || "—";

    $("editModal").classList.remove("hidden");
    lockTouch(true);
  }

  $("btnToggleDetails").addEventListener("click", ()=>{
    detailsShown = !detailsShown;
    $("editDetailsBox").classList.toggle("hidden", !detailsShown);
    $("btnToggleDetails").textContent = detailsShown ? "Hide Details" : "View/Edit Details";
  });

  $("btnEditClose").addEventListener("click", ()=>{
    $("editModal").classList.add("hidden");
    lockTouch(false);
  });

  $("btnEditSave").addEventListener("click", ()=>{
    if(!currentSelectedId) return;
    const idx = records.findIndex(r=>r.id===currentSelectedId);
    if(idx<0) return;

    const ts = fromDTLocalValue($("editDT").value);
    const numRaw = ($("editNum").value || "").trim();
    const card = buildAngelCard(numRaw);
    const notes = ($("editNotes").value || "").trim();
    const updated = {
      ...records[idx],
      ts,
      number: card.number || numRaw,
      pattern: classifyPattern(card.number || numRaw),
      meaning: card.meta || "",
      notes
    };

    records[idx] = updated;
    records.sort((a,b)=> b.ts - a.ts);
    saveRecords(records);

    // refresh edit top card
    const c2 = buildAngelCard(updated.number);
    $("editAngelHeader").textContent = `Angel Card Number: ${c2.number || updated.number || "—"}`;
    $("editAngelBig").textContent = c2.number || updated.number || "—";
    $("editAngelCard").textContent = c2.meta || updated.meaning || "—";
    $("editPattern").textContent = updated.pattern || "—";

    renderCalendar();
    openInfo("Saved", "Entry updated.", {mode:"info"});
  });

  $("btnEditDelete").addEventListener("click", ()=>{
    if(!currentSelectedId) return;
    const idx = records.findIndex(r=>r.id===currentSelectedId);
    if(idx<0) return;

    const rec = records[idx];
    const msg = `Delete this entry?\n\n${fmtDateTime(rec.ts)}\nNumber: ${rec.number}\nNotes: ${rec.notes || "None"}`;
    openInfo("Confirm delete", msg, {mode:"confirmDelete", okText:"Delete"});
  });

  $("btnEditExport").addEventListener("click", ()=>{
    if(!currentSelectedId) return;
    const rec = records.find(r=>r.id===currentSelectedId);
    if(!rec){
      openInfo("Export", "Entry not found.", {mode:"info"});
      return;
    }
    const report = buildEntryReport(rec);
    openExport(report);
  });

  // Info modal buttons
  $("btnInfoX").addEventListener("click", closeInfo);

  $("btnInfoOk").addEventListener("click", ()=>{
    const mode = $("btnInfoOk").dataset.mode || "info";
    if(mode === "confirmDelete"){
      // perform delete
      if(currentSelectedId){
        records = records.filter(r=>r.id!==currentSelectedId);
        saveRecords(records);
        currentSelectedId = null;
        renderCalendar();
        $("editModal").classList.add("hidden");
      }
      closeInfo();
      openInfo("Deleted", "Entry deleted.", {mode:"info"});
      return;
    }

    if(mode === "installDone"){
      closeInfo();
      // Attempt to close the tab/window.
      // Note: most browsers will block this unless the tab was opened by script.
      try{ window.close(); }catch{}
      setTimeout(()=>{
        if(!document.hidden){
          openInfo("Close this tab", "If this didn’t close automatically, close the tab or use your back button.\n\nThen launch the installed app icon for the best experience.", {mode:"info"});
        }
      }, 260);
      return;
    }

    closeInfo();
  });

  // Export modal buttons
  $("btnExportOk").addEventListener("click", closeExport);

  $("btnExportCopy").addEventListener("click", async ()=>{
    const text = $("exportReportBox").textContent || "";
    try{
      const ok = await copyToClipboard(text);
      if(ok){
        openInfo("Copied", "Report copied to clipboard.", {mode:"info"});
      }else{
        openInfo("Copy", "Copy is not available on this browser.", {mode:"info"});
      }
    }catch{
      openInfo("Copy failed", "Could not copy to clipboard.", {mode:"info"});
    }
  });

  $("btnExportShare").addEventListener("click", async ()=>{
    const text = $("exportReportBox").textContent || "";
    if(!isShareAvailable()){
      openInfo("Share", "Share is not available on this browser.", {mode:"info"});
      return;
    }
    try{
      await navigator.share({ title:"Angel Code Report", text });
    }catch{
      // user cancelled or failed
    }
  });

  $("btnExportSave").addEventListener("click", async ()=>{
    const text = $("exportReportBox").textContent || "";
    const name = `angel_code_report_${new Date().toISOString().slice(0,10)}.txt`;
    try{
      const usedPicker = await saveTextWithPicker(text, name);
      if(!usedPicker){
        downloadText(text, name);
      }
      openInfo("Saved", "Report saved.", {mode:"info"});
    }catch{
      // fallback
      try{
        downloadText(text, name);
        openInfo("Saved", "Report saved.", {mode:"info"});
      }catch{
        openInfo("Save failed", "Could not save report.", {mode:"info"});
      }
    }
  });

  // Reports
  function buildIdentifyReport(number){
    const now = new Date();
    const gen = fmtDateTime(now.getTime());
    const card = buildAngelCard(number);
    const lines = [];
    lines.push(`Angel Code — Report`);
    lines.push(`App Version: ${APP_VERSION}`);
    lines.push(`Report: Angel Card (Identify)`);
    lines.push(`Generated: ${gen}`);
    lines.push(`Range: Current identify number (Home screen)`);
    lines.push(`How this data was captured:`);
    lines.push(`- This Angel Card was generated from a number entered manually on this device.`);
    lines.push(`- Data is local-only (no cloud sync, no account).`);
    lines.push(`- The report contains the current number and its Angel Card text from the Home screen.`);
    lines.push(`------------------------------`);
    lines.push(`Number: ${card.number || number}`);
    lines.push(`Pattern: ${card.pattern || classifyPattern(card.number || number)}`);
    lines.push(``);
    lines.push(`${card.meta || ""}`);
    return lines.join("\n");
  }

  function buildEntryReport(rec){
    const now = new Date();
    const gen = fmtDateTime(now.getTime());
    const when = fmtDateTime(rec.ts);
    const card = buildAngelCard(rec.number);

    const lines = [];
    lines.push(`Angel Code — Report`);
    lines.push(`App Version: ${APP_VERSION}`);
    lines.push(`Report: View & Update Export`);
    lines.push(`Generated: ${gen}`);
    lines.push(`Entry: ${when}`);
    lines.push(`How this data was captured:`);
    lines.push(`- Sightings are entered manually into Angel Code on this device.`);
    lines.push(`- Data is stored locally on the phone (no cloud sync, no account).`);
    lines.push(`- Each record includes date/time, number, pattern, Angel Card text, and optional notes.`);
    lines.push(`This export contains the selected entry and its Angel Card as shown in View & Update.`);
    lines.push(`------------------------------`);
    lines.push(`Date/Time: ${when}`);
    lines.push(`Number: ${rec.number}`);
    lines.push(`Pattern: ${rec.pattern || card.pattern || "—"}`);
    lines.push(`Notes: ${rec.notes ? rec.notes : "None"}`);
    lines.push(``);
    lines.push(`${card.meta || rec.meaning || ""}`);
    return lines.join("\n");
  }

  // Initial render & setup
  function init(){
    setMonthToNow();
    renderCalendar();
    updateFooterVersion();

    // Home post-submit section stays hidden until user submits
    // but footer needs version once shown; handled in doHomeSubmit

    updateInstallButtons();
    // also wire small install button presence (it’s under after-submit)
    // This will be updated when after-submit becomes visible.
  }

  init();

})();
  </script>

<!--
Angel Code — EOF Version Detail Notes
App Version: v1.2A11
Base: v1.2A10
Changes (requested):
- Add a large, high-visibility Install button on the Home/Entry screen under the main pill row.
- On tap, show an “Installing…” message immediately.
- After install (accepted), show a completion message with OK that attempts to close the current tab/window.
- Big Install button uses same install availability logic as the small Install button.
-->
</body>
    </html>
